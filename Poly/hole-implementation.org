* First try
 - The naive implementation of just instantiating a fresh name for each hole doesn't work.
   - Because, look at the term /let f = ? in f 1/. The hole should have a type of /int -> c/ for all /c/.
   - The inference rule for /let/ will generalise the type it's inferred for /f/, namely /a/ (a fresh variable for the hole)
   - The generalisation of /a/ is /âˆ€ a . a/.
   - Then, when the type of /f/ is inferred in the application /f 1/, it's instantiated, giving a new fresh variable, /b/
   - This application gives the constraint  /b ~ int \rightarrow  c/.
 - Clearly, there's nothing that can be written in /infer (Hole n) = .../ to make this work
   - Instead, all the holes must be discovered before type-checking, and then can be added as a monomorphic
	 type to the environment

	
