__comp f g x = f (g x);

id x = x;

swap f x y = f y x;

const x y = x;

not b = if b then False else True;

fix f = f (fix f);

append xs ys =
  if null xs
  then ys
  else head xs :: append (tail xs) ys;

__app = append;

reverse xs =
  let rec rev-aux xs acc =
    if null xs
	then acc
	else rev-aux (tail xs) (head xs :: acc)
  in rev-aux xs [];

take n xs =
  if n == 0
  then []
  else head xs :: take (n - 1) (tail xs);

drop n xs =
  if n == 0
  then xs
  else drop (n - 1) (tail xs);

seq n = n :: seq (n + 1);

repeat a = a :: repeat a;

range m n =
  if m == n
  then [m]
  else m :: range (m + 1) n;

map f xs =
  if null xs
  then []
  else f (head xs) :: map f (tail xs);

foldr f z xs =
  if null xs
  then z
  else f (head xs) (foldr f z (tail xs));

sum = foldr (+) 0;

length xs =
  if null xs
  then 0
  else 1 + length (tail xs);

zipWith f xs ys =
  if null xs
  then []
  else if null ys
       then []
	   else f (head xs) (head ys) :: zipWith f (tail xs) (tail ys);

zip = zipWith (\x y -> (x, y));

enumerate = zip (seq 0);

filter p xs =
  if null xs
  then []
  else let hd = head xs in
  	   let tl = tail xs in
	   if p hd
	   then hd :: filter p tl
	   else filter p tl;
