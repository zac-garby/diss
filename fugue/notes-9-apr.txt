length : [a] -> Int
    { [] -> 0
    , [1] -> 1
    , [1, 2, 3] -> 3 }
length xs = case xs of
    [] -> f xs
    (y:ys) -> let l = length ys
              in g xs y ys l

f : [a] -> Int
    { [] -> 0 }
f xs = 0

g : [a] -> a -> [a] -> Int -> Int
    { [1], 1, [], 0 -> 1
    , [1, 2, 3], 1, [2, 3], <g [2, 3] 2 [3] (g [3] 3 [] 0)> -> 3 }
g xs y ys l = Suc (h xs y ys l)

h : [a] -> a -> [a] -> Int -> Int
    { [1], 1, [], 0 -> 0
    , [1, 2, 3], 1, [2, 3], <Suc (h [2, 3] 2 [3] (Suc (h [3] 3 [] 0)))> -> 2 }
h xs y ys l = i xs y ys l

i : [a] -> a -> [a] -> Int -> Int
    { [1], 1, [], 0 -> 0
    , [1, 2, 3], 1, [2, 3], 2 -> 2
    , [3], 3, [], 0 -> 0
    , [2, 3], 2, [3], 1 -> 1 }
i xs y ys l = l



h xs y ys l = l

g xs y ys l = Suc l

length xs = case xs of
    [] -> 0
    (y:ys) -> Suc (length ys)


{-

TODO:
 * Synthesising things like eg : { [] -> 0 } without excessive noise
   - can this be done by simply only allowing a "solo example rule" to apply immediately after
     after a case-split?
   - perhaps even only after a recursive split, and only on non-recursive cases? <- this
-}

length : [a] -> Int
    { [] -> 0
    , [1] -> 1
    , [1, 2, 3] -> 3 }
length xs = case xs of
    [] -> f xs
    (y:ys) -> let l = length ys
              in g xs y ys l

f : [a] -> Int
    { [] -> 0 }
f xs = 0

{-

length [2, 3] | length
    = let l = length [3] in g [2, 3] 2 [3] l | length
    = let l = (let l' = length [] in g [3] 3 [] l' | length) in g [2, 3] 2 [3] l | length
    = let l = (g [3] 3 [] 0 | g) in g [2, 3] 2 [3] l | g
-}

g : [a] -> a -> [a] -> Int -> Int
    { [1], 1, [], 0 -> 1
    , [1, 2, 3], 1, [2, 3], <let l = (g [3] 3 [] 0 | g) in g [2, 3] 2 [3] l | g> -> 3 }
g xs y ys l = Suc (h xs y ys l)

h : [a] -> a -> [a] -> Int -> Int
    { [1], 1, [], 0 -> 0
    , [1, 2, 3], 1, [2, 3], <let l = (Suc (h [3] 3 [] 0 | h)) in g [2, 3] 2 [3] l | h> -> 2 }
h xs y ys l = case ys of
    [] -> l
    (z:zs) -> i xs y ys l z zs

{-
let l = (Suc (h [3] 3 [] 0 | h)) in g [2, 3] 2 [3] l | h
    = ( let l = (Suc 0) in g [2, 3] 2 [3] l | h )
    = g [2, 3] 2 [3] 1 | g
    = Suc (h [2, 3] 2 [3] 1) | h
    = Suc (i [2, 3] 2 [3] 1 3 []) | i
-}

i : [a] -> a -> [a] -> Int -> a -> [a] -> Int
    { [1, 2, 3], 1, [2, 3], <Suc (i [2, 3] 2 [3] 1 3 []) | i>, 2, [3] -> 2 }
i xs y ys l z zs = j xs y ys l z zs -- unify

j : [a] -> a -> [a] -> Int -> a -> [a] -> Int
    { [1, 2, 3], 1, [2, 3], 2, 2, [3] -> 2
 *> , [2, 3],    2, [3],    1, 3, []  -> 1 } -- via unification
j xs y ys l z zs = l




{-
i : [a] -> a -> [a] -> Int -> Int
    { [1], 1, [], 0 -> 0
    , [1, 2, 3], 1, [2, 3], 2 -> 2 -- h [2, 3] 2 [3] l ~ 1; l ~ 1; Suc (h [3] 3 [] 0) ~ 1; h [3] 3 [] 0 ~ 0
 *> , [3], 3, [], 0 -> 0
 *> , [2, 3], 2, [3], 1 -> 1 }
i xs y ys l = l
-}


-- **** TODO ****
{-

 * length : List a -> a
   length a = case a of
    Nil -> Zero,
    Cons d e -> let g = length e
                in Suc (case e of Nil -> g, Cons s t -> s)
   should not be valid, because `Zero` is not of type `a`. In general, types need to be checked in the
   trivial rule

 * clean up e.g. `(case e of Nil -> g, Cons s t -> g)` -> `g`
    - disallow recursive calls with no recursion (or transform into regular `case`)
    - remove unused arguments in all but the root function
-}